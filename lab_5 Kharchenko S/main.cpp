#include <iostream>
#include <cmath>
using namespace std;

//Завдання 1. Дано дійсні числа (xi, yi), i = 1,2, ... n, – координати точок на 
//площині.Визначити кількість точок, що потрапляють в фігуру заданого
//кольору(або групу фігур).
float figure_16(float x, float y, float r)//функція, яка окреслює положення точки
{
    bool in_left_bottom_side, in_right_top_side; //ініціалізація змінних, які є представниками відповідних для варіанту секторів 
    
    if ((y < (-x - (2 * r))) && (x < -r) && (((x + r) * (x + r)) + ((y + r) * (y + r)) < (r * r))) //умова, яка допоможе визначити чи точка належить до частини відповідного до варіанту сектору(зліва знизу) 
        in_left_bottom_side = true; // при позитивному результаті виконання умови в змінній записує означення "true"
    else
        in_left_bottom_side = false; // при негативному резулітаті виконання умови в змінній записується означення "false"

    if ((y < (-x + (2 * r))) && (y > 0) && (x > r) && (((x - r) * (x - r)) + ((y - r) * (y - r)) >= (r * r))) //умова, яка допоможе визначити чи точка належить до частини відповідного до варіанту сектору(з права знизу)
        in_right_top_side = true; // при позитивному результаті виконання умови в змінній записує означення "true"
    else
        in_right_top_side = false; // при негативному резулітаті виконання умови в змінній записується означення "false"

    if (in_left_bottom_side == true || in_right_top_side == true) //умова, яка при позитивному розгляді поверне вартість 1, а вразі негативної - 0
        return 1;
    else
        return 0;
}

void task_1() //функція, яка реалізує виконання завдання 1
{
    int count = 0; //ініціалізація змінної, яка зберігає кількість точок, які виконують умови завдання згідно з варіантом (початкова вартість 0)
    int point_count = 0; //ініціалізація змінної, яка зберігає загальну кількість точок, які були введені

    cout << "Кількість точок для розрахунку: ";
    cin >> point_count;

    for (int i = 0; i < point_count; i++) //цикл, який дозволяє вводити дані точок та радіуси кіл та перевіряти їх на предмет виконання умов завдання
    {
        float x, y, r; //ініціалізація координат точки та радіус кола в дійсному типі даних
        cout << "Введіть координату х точки: ";
        cin >> x;
        cout << "Введіть координату y точки: ";
        cin >> y;
        cout << "Введіть радіус кола: ";
        cin >> r;

        if (figure_16(x, y, r) == 1) //якщо результат функції figure_16 дорівнює нулю, тоді кількість точок, які виконують умову завдання збільшується на один
            count++;
    }

    cout << "Кількість точок, які виконують умову завдання становить: " << count << " з " << point_count << endl;
    cout << endl;
}

//Завдання 2. Дано дійсне число х і натуральне число n.Необхідно:
//a) Обчислити значення виразу при заданих x і n для виразу з варіанту
//b) Вивести: для парних варіантів – значення кожного третього
//елемента, для непарних – значення кожного четвертого елемента.
int factorial(unsigned int k) //функція, яка рахує і повертає факторіал числа k потрібний для обчислень в формулі
{
    long long factorial = 1; //змінна видовженого цілковитого типу(більше за int та long), яка потім буде зберігати вартість факторіалу числа k
    int i; //змінна цілковитого типу, яка буде надавати числа для розрахунку факторіалу і в одночас буде контролювати кількість виконаних циклів
    for (i = 1; i <= k; ++i)//цикл, який дозволяє обчислити факторіал 
    {
        factorial *= i;
    } 

    return factorial;
}

void task_2() //функція, яка реалізує виконання завдання 2
{
    float x; //ініціалізація довільного числа задекларованого в дійсному типі змінних
    unsigned int n; //ініціалізація кількості елементів ряду, які ми хочемо розрахувати в цілковитому типі даних, проте більших за нуль (натуральні числа)
    unsigned int k; //ініціалізація порядкового номера елемента ряду в цілковитому типі даних, проте більших за нуль (натуральні числа)
    float sum, elem; //ініціалізація змінних, які зберігають вартість суми усіх елементів (sum) та конкретна вартість відповідного елемента після обчислень

    cout << "Введіть довільне число: ";
    cin >> x;

    cout << "Кількість елементів, з яких ми хочемо обчислити суму ряду: ";
    cin >> n;

    for (k = 1; k <= n; k++) //цикл, який виконує дії вказані в умові завдання 
    {
        elem = (pow(x, (k - 1)) / factorial(k));
        sum += elem;
        if (k % 4 == 0) //умова, яка перевіріє чи обчисльваний елемент ряду є кратним чотирьом (4. елемент, 8. елемент, і т. д.), якщо умова виконується, тоді вартість елементу має бути виведенна на екран
            cout << "Вартість " << k << " елементу становить: " << elem << endl;
    }

    cout << "Сума перших " << n << " елементів ряду становить: " << sum << endl;
    cout << endl;
}

//Завдання 3. Дослідити ряд на збіжність. 
int factorial_1(unsigned int n) //функція, яка обчислює фартість факторіалу n! з формули ряду
{
    long long factorial_1 = 1; //змінна видовженого цілковитого типу(бідьше за int та long), яка потім буде зберігати вартість факторіалу числа n
    int i; //змінна цілковитого типу, яка буде надавати числа для розрахунку факторіалу і в одночас буде контролювати кількість виконаних циклів
    for (i = 1; i <= n; ++i)
    {
        factorial_1 *= i;
    } 

    return factorial_1;
}

int factorial_2(unsigned int n) //функція, яка обчислює фартість факторіалу (2n)! з формули ряду
{
    long long factorial_2 = 1; //змінна видовженого цілковитого типу(більше за int та long), яка потім буде зберігати вартість факторіалу числа 2n
    int i; //змінна цілковитого типу, яка буде надавати числа для розрахунку факторіалу і в одночас буде контролювати кількість виконаних циклів
    for (i = 1; i <= (2 * n); ++i)
    {
        factorial_2 *= i;
    }

    return factorial_2;
}

void task_3() //функція, яка реалізує виконання завдання 3
{
    unsigned int n = 1; //ініціалізація порядкового номера елемента ряду в цілковитому типі даних, проте більших за нуль (натуральні числа)
    double e = pow(10 , -2); //ініціалізація числа е, яке буде обмежувати обчислення нескінченного ряду до завданого числа дійсного типу 
    double sum, elem; //ініціалізація змінних, які зберігають вартість суми усіх елементів (sum) та конкретна вартість відповідного елемента після обчислень

    elem = (factorial_1(n) * n) / factorial_2(n); //спосіб обчислення одного елемента в ряді 
    sum = elem; 

    while (fabs(elem) >= e)
    {
        cout << "Вартість елемента: " << elem << endl;
        n = n + 1; //збільшуємо порядковий номер елемента
        elem = (factorial_1(n) * n) / factorial_2(n);
        sum += elem;
    }

    cout << "Останній елемент ряду:" << elem << endl; 
    cout << "Сума цього ряду:" << sum << endl;
    cout << "Цей ряд буде збіжний." << endl;
    cout << endl;
}

int main() //головне меню
{
    int num_menu; //ініціалізація змінної, яка визначає номер завдання, яке треба виконати

    do
    {
        cout << "Введіть номер завдання до виконання: ";
        cin >> num_menu;
        switch (num_menu)
        {
            case 1: task_1(); break;
            case 2: task_2(); break;
            case 3: task_3(); break;
            case -1: cout << "Вихід з виконання завдань." << endl; break;
            default: cout << "Wrong task!" << endl;
        }
    } 
    while (num_menu != -1);
    
    cout << endl;

    return 0;
}